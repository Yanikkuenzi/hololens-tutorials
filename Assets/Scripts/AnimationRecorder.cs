using System.Collections;
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using UnityEngine.XR.ARSubsystems;
using Microsoft.MixedReality.Toolkit.UI.Editor;
using Microsoft.MixedReality.Toolkit.Input;
using System;

#if ENABLE_WINMD_SUPPORT
using Windows.Storage;
#endif

public class AnimationRecorder : MonoBehaviour
{
    private ArrayList points;
    private ArrayList colors;

    private bool recording;
#if ENABLE_WINMD_SUPPORT
        HL2ResearchMode researchMode;
#endif

    // Start is called before the first frame update
    void Start()
    {
        points = new ArrayList();
        colors = new ArrayList();
        recording = false;
    }

    // Update is called once per frame
    void Update()
    {
 #if ENABLE_WINMD_SUPPORT
        if (!recording || !researchMode.PointCloudUpdated())
            return;

        float[] pointCloud = researchMode.GetPointCloudBuffer();
        int nPoints = pointCloud.Length / 3;
        if (nPoints > 0)
        {
            int idx = points.Add(new Vector3[nPoints]);
            colors.Add(new Color[nPoints]);
            for (int i = 0; i < nPoints; i++)
            {
                points[idx][i] = new Vector3(points[3 * i], points[3 * i + 1], points[3 * i + 2]);
                // TODO: capture color
                colors[idx][i] = Color.magenta;
            }
            this.points.Add(points);
        }
#endif
    }

    void ExportToFiles(string directory)
    {
#if ENABLE_WINMD_SUPPORT
        StorageFolder objects_3d = KnownFolders.Objects3D;
        // Prepend storage location
        directory = objects_3d.Path + "/" + directory;
        for (int i = 0; i < points.Count; i++)
        {
            // Use the index of the pointcloud in the animation as its file name
            using (StreamWriter writer = new StreamWriter(directory + string.Format("{0:D6}.ply")))
            {
                // Use same format as point clouds expoted using Open3d
                string header = string.Format("ply\nformat ascii 1.0\nComment Generated by Floating Hands\n" +
                    "element vertex {0}" +
                    "property double x\nproperty double y\n property double z\n" +
                    "property uchar red\nproperty uchar green\n property uchar blue\n" +
                    "end_header", points[i].Length);
                
                writer.WriteLine(header);
                // Write each point and its corresponding color
                for(int j = 0; j < points[i].Length; j++)
                {
                    writer.WriteLine(string.Format("{0} {1} {2} {3} {4} {5}"),
                        points[i][j].x, points[i][j].y, points[i][j].z,
                        colors[i][j].r, colors[i][j].g, colors[i][j].b);
                }
            }

        }
#endif
        // Drop current animation as soon as its written to disk
        this.points = new ArrayList();
        this.colors = new ArrayList();

    }

    public void ToggleRecording()
    {
        recording = !recording;
        // Write captured point cloud animation to disk
        if (!recording)
        {
            ExportToFiles(DateTime.Now.ToString("dd-MM-yyyyTHH_mm"));
        }
    }
    private void InitResearchMode()
    {
#if ENABLE_WINMD_SUPPORT
        researchMode = new HL2ResearchMode();

        researchMode.InitializeDepthSensor();
        researchMode.InitializeSpatialCamerasFront();
        researchMode.SetReferenceCoordinateSystem(unityWorldOrigin);
        researchMode.SetPointCloudDepthOffset(0);

        researchMode.StartDepthSensorLoop(enablePointCloud);
        researchMode.StartSpatialCamerasFrontLoop();
#endif
    }

}
