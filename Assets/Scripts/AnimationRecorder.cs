using System.Collections;
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using UnityEngine.XR.ARSubsystems;
using Microsoft.MixedReality.Toolkit.Input;
using System.Runtime.InteropServices;
using System;

#if ENABLE_WINMD_SUPPORT
using Windows.Storage;
using HL2UnityPlugin;
#endif

public class AnimationRecorder : MonoBehaviour
{
    private ArrayList points;
    private ArrayList colors;

    public GameObject logger;
    private DebugOutput dbg;

    public double distance_threshold;

    private bool recording;
#if ENABLE_WINMD_SUPPORT
        HL2ResearchMode researchMode;
        Windows.Perception.Spatial.SpatialCoordinateSystem unityWorldOrigin;
#endif

    // Start is called before the first frame update
    void Start()
    {

#if ENABLE_WINMD_SUPPORT
        IntPtr WorldOriginPtr = UnityEngine.XR.WindowsMR.WindowsMREnvironment.OriginSpatialCoordinateSystem;
        unityWorldOrigin = Marshal.GetObjectForIUnknown(WorldOriginPtr) as Windows.Perception.Spatial.SpatialCoordinateSystem;
#endif
        points = new ArrayList();
        colors = new ArrayList();
        recording = false;

        // Square distance threshold for efficiency later
        distance_threshold *= distance_threshold;

        InitResearchMode();

        if(dbg == null)
        {
            dbg = logger.GetComponent<DebugOutput>();
            Debug.Log(string.Format("dbg in AR: {0}", dbg));
        }
    }

    void LateUpdate()
    {
#if ENABLE_WINMD_SUPPORT
        if (!recording) 
            return;

        try
        {
            if (!researchMode.PointCloudUpdated()) {
                //dbg.Log("Point cloud not updated");
                return;
            }

            dbg.Log("Recording");

            float[] pointCloud = researchMode.GetPointCloudBuffer();
            dbg.Log(string.Format("{0} points in PointCloudBuffer", pointCloud.Length));
            int nPoints = pointCloud.Length / 3;
            if (nPoints > 0)
            {
                int idx = points.Add(new Vector3[nPoints]);
                colors.Add(new Color[nPoints]);
                for (int i = 0; i < nPoints; i++)
                {
                    Vector3 coordinates = new Vector3(pointCloud[3 * i], pointCloud[3 * i + 1], pointCloud[3 * i + 2]);
                    if (coordinates.sqrMagnitude > distance_threshold)
                    {
                        coordinates = Vector.zero;
                    }
                    ((Vector3[])points[idx])[i] = coordinates;
                    // TODO: capture color
                    ((Color[])colors[idx])[i] = Color.magenta;
                }
            }
        } catch(Exception e)
        {
            dbg.Log(e.ToString());
        }
        dbg.Log(string.Format("Extended animation to {0} pointclouds", points.Count));
#endif
    }

    void ExportToFiles(string directory)
    {
        dbg.Log("Export");
#if ENABLE_WINMD_SUPPORT
        StorageFolder objects_3d = KnownFolders.Objects3D;
        // Prepend storage location and create output directory
        directory = objects_3d.Path + "/" + directory;
        Directory.CreateDirectory(directory);
        dbg.Log(string.Format("Started exporting {0} point clouds to {1}", points.Count, directory));
        for (int i = 0; i < points.Count; i++)
        {
            // Use the index of the pointcloud in the animation as its file name
            using (StreamWriter writer = new StreamWriter(directory + "/" + string.Format("{0:D6}.ply", i)))
            {
                Vector3[] curr_points = (Vector3[])points[i];
                Color[] curr_colors = (Color[])colors[i];
                // Use same format as point clouds expoted using Open3d
                string header = string.Format("ply\nformat ascii 1.0\nComment Generated by Floating Hands\n" +
                    "element vertex {0}\n" +
                    "property double x\nproperty double y\nproperty double z\n" +
                    "property uchar red\nproperty uchar green\nproperty uchar blue\n" +
                    "end_header\n", curr_points.Length);
                
                writer.WriteLine(header);
                // Write each point and its corresponding color
                for(int j = 0; j < curr_points.Length; j++)
                {
                    // Don't write points at origin
                    if (curr_points[j] == Vector.zero) 
                        continue;

                    writer.WriteLine(string.Format("{0} {1} {2} {3} {4} {5}",
                        curr_points[j].x, curr_points[j].y, curr_points[j].z,
                        (int)(curr_colors[j].r * 255), (int)(curr_colors[j].g * 255), (int)(curr_colors[j].b * 255)));
                }
            }

        }
#endif
        // Drop current animation as soon as its written to disk
        this.points = new ArrayList();
        this.colors = new ArrayList();

    }

    public void ToggleRecording()
    {
        dbg.Log("Toggled recording");
        recording = !recording;
        // Write captured point cloud animation to disk
        if (!recording)
        {
            try
            {
                ExportToFiles(DateTime.Now.ToString("dd-MM-yyyyTHH_mm"));
            }
            catch (Exception e)
            {
                dbg.Log(e.ToString());
            }
        }
    }
    private void InitResearchMode()
    {
#if ENABLE_WINMD_SUPPORT
        researchMode = new HL2ResearchMode();

        researchMode.InitializeDepthSensor();
        researchMode.InitializeSpatialCamerasFront();
        researchMode.SetReferenceCoordinateSystem(unityWorldOrigin);
        researchMode.SetPointCloudDepthOffset(0);

        researchMode.StartDepthSensorLoop(true);
        researchMode.StartSpatialCamerasFrontLoop();
#endif
    }

}
