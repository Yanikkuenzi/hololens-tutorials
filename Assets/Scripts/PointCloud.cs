using System;
using System.Collections;
using System.IO;
using UnityEngine;
using UnityEngine.UIElements;
using Tutorials;
using System.Runtime.InteropServices.ComTypes;
using System.Net.NetworkInformation;

public class PointCloud
{
    private ArrayList points;
    private ArrayList colors;
    private int number_of_points;

    public int Count
    {
        get => number_of_points;
    }


    public ArrayList Points
    {
        get => points;
    }

    public ArrayList Colors
    {
        get => colors;
    }

    /// <summary>
    /// Constructor creating a pointcloud from a given array of points.
    /// Applies distance filtering at the same time
    /// </summary>
    /// <param name="coordinates"></param>
    /// <param name="distance_threshold"></param>
    /// <exception cref="ArgumentNullException"></exception>
    /// <exception cref="ArgumentOutOfRangeException"></exception>
    public PointCloud(float[] coordinates, double distance_threshold)
    {
        if (coordinates == null)
            throw new ArgumentNullException(nameof(coordinates));
        int nPoints = coordinates.Length / 3;
        if (nPoints == 0)
            throw new ArgumentOutOfRangeException("Point cloud must contain at least one point");

        // Square distance threshold to compare it to squared magnitude later,
        // saves some square root computations
        distance_threshold *= distance_threshold;

        // Reserve enough space to avoid copy operations
        points = new ArrayList(nPoints);
        colors = new ArrayList(nPoints);

        for (int i = 0; i < nPoints; i++)
        {
            Vector3 point = new Vector3(coordinates[3 * i], coordinates[3 * i + 1], coordinates[3 * i + 2]);

            // Filter out far points
            if (point.sqrMagnitude > distance_threshold)
                continue;

            points.Add(point);
            // TODO: capture color
            colors.Add(Color.magenta);
        }
        // All of the inserted elements are valid
        number_of_points = points.Count;
    }

    public PointCloud(string filename)
    {
        FileHandler.LoadPointsFromPLY(filename, out points, out colors);
        number_of_points = points.Count;
    }

    public void ExportToPLY(string filename)
    {
        using (StreamWriter writer = new StreamWriter(filename))
        {
            // Use same format as point clouds expoted using Open3d
            string header = string.Format("ply\nformat ascii 1.0\nComment Generated by Floating Hands\n" +
                "element vertex {0}\n" +
                "property double x\nproperty double y\nproperty double z\n" +
                "property uchar red\nproperty uchar green\nproperty uchar blue\n" +
                "end_header", number_of_points);

            writer.WriteLine(header);
            // Write each point and its corresponding color
            for (int j = 0; j < number_of_points; j++)
            {
                Vector3 coordinates = (Vector3)points[j];
                Color point_color = (Color)colors[j];

                writer.WriteLine(string.Format("{0} {1} {2} {3} {4} {5}",
                    coordinates.x, coordinates.y, coordinates.z,
                    (int)(point_color.r * 255), (int)(point_color.g * 255), (int)(point_color.b * 255)));
            }
        }
    }

    /// <summary>
    /// Applies random down sampling with a sampling ration of expected_point/number_of_points.
    /// The expected number of points is therefore the parameter given to the function.
    /// If expected_points >= number_of_points, nothing will be done
    /// </summary>
    /// <param name="expected_points"></param>
    public void RandomDownSample(int expected_points)
    {
        // Initialize random number generator
        System.Random rnd = new System.Random();
        // Don't downsample if there are fewer points than what is expected
        if (expected_points >= number_of_points)
            return;

        // Probability of element being included in the downsampled point cloud
        double p = (double)expected_points / number_of_points;
        // Index of first element not belonging to downsampled array anymore
        int n = 0;
        for (int i = 0; i < number_of_points; i++)
        {
            // Keep element, copy it in region that contains valid points
            if (rnd.NextDouble() < p)
            {
                points[n] = points[i];
                colors[n++] = colors[i];
            }
        }
        number_of_points = n;
    }


    public void ColorFromImage(Texture2D texture, Matrix4x4 cameraMatrix)
    {
        // Ignore previous color information
        colors.Clear();

        // Debug
        float min_u = float.PositiveInfinity;
        float min_v = float.PositiveInfinity;
        float max_u = float.NegativeInfinity;
        float max_v = float.NegativeInfinity;

        float u_offset = cameraMatrix[0, 2];
        float v_offset = cameraMatrix[1, 2];

        foreach (Vector3 point in points)
        {
            // Convert 3d point in world coordinates to homogeneous point
            Vector4 homogeneous_point = point;
            homogeneous_point.w = 1;
            // Project to image plane (https://en.wikipedia.org/wiki/Camera_resectioning)
            // projected = z * [u, v, 1]^T = M * [x, y, z, 1]^T
            Vector3 projected = cameraMatrix * homogeneous_point;
            // Convert to homogeneous coordinates, z coordinate must be 1
            projected /= projected.z;
            // Translate between coordinate systems as (0,0) is in the bottom left corner of
            // of the uv coordinate system used by Texture2D and not centered
            float u = (projected.x + u_offset);
            float v = (projected.y + v_offset);

            // TODO: remove, only for debugging purposes
            min_u = Math.Min(u, min_u);
            min_v = Math.Min(v, min_v);
            max_u = Math.Max(u, max_u);
            max_v = Math.Max(v, max_v);
            //Debug.Log(string.Format("Getting pixel at ({0}, {1})", u, v));

            // Assign the current point the right color corresponding to its projection onto 
            // the image plane
            colors.Add(texture.GetPixelBilinear(u, v));
        }
        Debug.Log(string.Format("Texture has dimensions: {0} x {1}", texture.width, texture.height));
        Debug.Log(string.Format("Center is at ({0}, {1})", u_offset, v_offset));
        Debug.Log(string.Format("(min_u, min_v) = ({0}, {1})", min_u, min_v));
        Debug.Log(string.Format("(max_u, max_v) = ({0}, {1})", max_u, max_v));
    }
}
